package ru.yandex.practicum.sprint3final.a;

/**
 * A. Поиск в сломанном массиве
 * <p>
 * -- ПРИНЦИП РАБОТЫ --
 * Бинарный поиск с измененной проверкой.
 * <p>
 * -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 * Хотя сам массив не отсортирован по возрастанию, участки, на которые мы разделяем массив при бинарном поиске
 * могут быть отсортированными. Так как все элементы уникальные, то отдельно взятый участок будет отсортированным,
 * если его крайний левый элемент строго меньше крайнего правого. Если попадаем на отсортированный участок, то
 * если искомое значение находится в диапазоне между крайним левым и крайним правым значением, значит имеет смысл
 * продолжить поиск в только на этом участке.
 * <p>
 * Если участок поиска не отсортирован, мы все равно можем сделать вывод о том, может ли искомое значение
 * принадлежать промежутку: искомое значение должно быть либо больше крайнего правого, либо меньше крайнего левого.
 * Точнее, в этом случае мы можем сделать вывод о том, что значения может точно не быть. Например, возьмем
 * последовательность [10, ..., 2] и искомый элемент 3. Можем сделать однозначный вывод, что искомого элемента в
 * последовательности нет. Т.к. "вправо" последовательность может только возрастать, а "влево" только убывать.
 * <p>
 * Элементы уникальные, а "неотсортированный" участок при разделении массива на части может быть только 1 (или 0), а
 * значит, можем сделать однозначный вывод, в какой части, левой или правой, продолжать поиск и продолжать ли его
 * в принципе.
 * <p>
 * -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 * В среднем и худшем случае временная сложность логарифмическая O(log N). В лучшем случае (например, последовательность
 * из одного элемента) временная сложность будет константной O(1).
 * <p>
 * -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 * Я добавил 4 переменные в функцию {@link #find(int[], int, int, int)} для читаемости и предотвращения повторных
 * операций, что формально делает пространственную сложность зависящей от глубины рекурсии, т.е. O(log N). На каждый шаг
 * рекурсии потребуется по 8 байт (4 int по 2 byte). Но если не выделять эти значения в отдельные переменные, то
 * пространственная сложность будет константной O(1), т.е. дополнительной памяти не потребуется (второй run-report).
 * Но, думается, что в абсолютных величинах это мизерные значения, которыми можно пренебречь, если нет дополнительных
 * ограничений.
 *
 * @see <a href="https://contest.yandex.ru/contest/23815/run-report/69545408/">
 * Run Report. ID 69545408. O(log N) space complexity</a>
 * @see <a href="https://contest.yandex.ru/contest/23815/run-report/69545434/">
 * Run Report. ID 69545434. O(1) space complexity</a>
 */
public final class Solution_sprint3final_a_recursive {

    private static final int NOT_FOUND = -1;

    public static int brokenSearch(final int[] arr, final int k) {
        return find(arr, k, 0, arr.length - 1);
    }


    /**
     * Находит элемент в массиве arr на диапазоне от from(inclusive) до to(exclusive).
     * <p>
     * Возвращает {@link #NOT_FOUND} если элемент не найден
     *
     * @param arr  массив, в котором производится поиск
     * @param k    искомый элемент
     * @param from индекс, откуда начинать поиск (inclusive)
     * @param to   индекс, где заканчивать поиск (exclusive)
     * @return индекс искомого элемента или {@link #NOT_FOUND}, если элемент отсутствует
     */
    private static int find(final int[] arr, final int k, final int from, final int to) {
        if (from == to - 1) return arr[from] == k ? from : NOT_FOUND; // базовый случай для отрезка из одного элемента

        final int midElementIndex = (from + to) / 2;
        final int midElement = arr[midElementIndex];
        final int leftElement = arr[from];
        final int rightElement = arr[to - 1];

        if (midElement == k) return midElementIndex; // базовый случай, если центральный элемент – искомый

        // если продолжение поиска имеет смысл, то рекурсивно ищем дальше либо слева, либо справа
        if (isInRange(k, leftElement, midElement)) return find(arr, k, from, midElementIndex);
        if (isInRange(k, midElement, rightElement)) return find(arr, k, midElementIndex, to);

        return NOT_FOUND;
    }

    /**
     * Проверяет, возможно ли нахождение искомого элемента в диапазоне.
     * <p>
     * Результат false означает, что элемента точно нет в диапазоне, а результат true – что элемент может быть,
     * а может и отсутствовать.
     *
     * @param k            искомый элемент
     * @param leftElement  значение элемента слева
     * @param rightElement значение элемента справа
     * @return возможно ли, что элемент находится в диапазоне от leftElement до rightElement
     */
    private static boolean isInRange(final int k, final int leftElement, final int rightElement) {
        if (leftElement < rightElement) { // на этом участке элементы отсортированы корректно
            return leftElement <= k && k <= rightElement; // может ли искомый элемент находиться в диапазоне
        } else { // на этом участке элементы отсортированы некорректно
            return leftElement <= k || k <= rightElement; // может ли искомый элемент находиться в диапазоне
        }
    }
}
